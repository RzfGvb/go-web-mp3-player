package main

import (
	"encoding/json"
	"fmt"
	"golang.org/x/net/context"
	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/drive/v3"
	"google.golang.org/api/googleapi"
	"gopkg.in/gin-gonic/gin.v1"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
)

const PORT = ":8090"

var (
	config   *oauth2.Config
	ctx      = context.Background()
	tok      *oauth2.Token
	client   *http.Client
	service  *drive.Service
	services = make(map[string]*drive.Service)
)

func main() {
	config = getConfig()
	router := gin.Default()
	router.GET("/link", handleLink)
	router.GET("/new/", handleNew)
	router.POST("/files", handleFiles)
	router.Run(PORT)
}

//-----------------------
//-- Structs and methods
//-----------------------

type file struct {
	Name string `json:"name"`
	Link string `json:"link"`
	//Tags []string `json:"tags"`
}

type fileList []file

func (fl fileList) ToJson() string {
	fs, err := json.Marshal(fl)
	chk.Chk(err)
	return string(fs)
}

//-----------------------
//-- Handlers
//-----------------------

func handleLink(c *gin.Context) {
	config.RedirectURL = c.Query("link")
	authURL := config.AuthCodeURL("state-token", oauth2.AccessTypeOffline, oauth2.AccessTypeOnline)
	fmt.Fprint(c.Writer, authURL)
}

func handleNew(c *gin.Context) {
	code := c.Query("code")
	if code == "" {
		log.Fatal("No code")
	}
	var err error
	tok, err = config.Exchange(ctx, code)
	if err != nil {
		log.Printf("Unable to retrieve token from web %v", err)
		return
	}
	fmt.Println("tok: ", tok.AccessToken)
	client = config.Client(ctx, tok)
	service, err = drive.New(client)
	x, err := service.About.Get().Fields("user(permissionId, emailAddress)").Do()
	if err != nil {
		fmt.Println("err: ", err.Error())
	}
	fmt.Println("email: ", x.User.EmailAddress)
	id := x.User.PermissionId
	fmt.Println("pId: ", id)
	services[id] = service
	fmt.Println("len: ", len(services))
	if err != nil {
		log.Fatalf("Unable to retrieve drive Client %v", err)
	}
	c.Writer.Write([]byte(id))
}

func handleFiles(c *gin.Context) {
	r, e := ioutil.ReadAll(c.Request.Body)
	chk.Chk(e)
	fmt.Println("body: ", string(r))
	id := string(r)
	filenames := make([]file, 0, 10)
	var f1 file
	services[id].Files.List().
		Fields(createField("id", "name", "webContentLink")).
		Q("mimeType='audio/mpeg'").
		Pages(ctx, func(fs *drive.FileList) error {
			for _, f := range fs.Files {
				f1 = file{Name: f.Name, Link: f.WebContentLink}
				filenames = append(filenames, f1)
			}
			return nil
		})
	fmt.Fprint(c.Writer, fileList(filenames).ToJson())
}

//-------------------
//-- Just functions
//-------------------

func getConfig() *oauth2.Config {
	b, err := ioutil.ReadFile("client_secret.json")
	if err != nil {
		log.Fatalf("Unable to read client secret file: %v", err)
	}

	config, err := google.ConfigFromJSON(b, drive.DriveScope)
	if err != nil {
		log.Fatalf("Unable to parse client secret file to config: %v", err)
	}
	return config
}

func createField(fs ...string) googleapi.Field {
	//arr := make([]string, len(fs))
	//for i, s := range fs {
	//	arr[i] = s
	//}

	return googleapi.Field(
		"files(" + strings.Join(fs, ",") + ")",
	)
}
